# STM32_MP25 - Librairie Capteur PM2.5 SEN0177

[![License](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
[![Platform](https://img.shields.io/badge/Platform-STM32L4-green.svg)](https://www.st.com/en/microcontrollers-microprocessors/stm32l4-series.html)

Librairie optimis√©e pour capteur de particules fines PM2.5 SEN0177 (DFRobot) sur microcontr√¥leurs STM32 avec HAL.

## üìã Table des mati√®res

- [Vue d'ensemble](#vue-densemble)
- [Caract√©ristiques](#caract√©ristiques)
- [Installation](#installation)
- [Configuration](#configuration)
- [API Reference](#api-reference)
- [Exemples d'utilisation](#exemples-dutilisation)
- [Architecture](#architecture)
- [Optimisations](#optimisations)
- [D√©pannage](#d√©pannage)

## üéØ Vue d'ensemble

Cette librairie fournit une interface compl√®te et optimis√©e pour le capteur PM2.5 SEN0177 de DFRobot. Elle supporte plusieurs modes de fonctionnement :

- **Mode Polling** : Lecture p√©riodique avec gestion d'√©tat optimis√©e
- **Mode DMA + Interruptions** : Lecture continue haute performance
- **Mode Continu** : Surveillance en temps r√©el

### Donn√©es mesur√©es

Le capteur fournit les mesures suivantes :

- **PM1.0, PM2.5, PM10** (standard et atmosph√©rique)
- **Particules par taille** : 0.3¬µm, 0.5¬µm, 1.0¬µm, 2.5¬µm, 5.0¬µm, 10¬µm
- **Version firmware** et **checksum**

## ‚ú® Caract√©ristiques

### üîß Fonctionnalit√©s principales

- ‚úÖ **2 modes de lecture** : Polling et DMA
- ‚úÖ **Gestion d'√©nergie** : Activation/d√©sactivation automatique
- ‚úÖ **Validation robuste** : Header et checksum
- ‚úÖ **Interpr√©tation qualit√© air** : Codes couleur et labels
- ‚úÖ **Mode debug** configurable
- ‚úÖ **Buffer circulaire** optimis√©
- ‚úÖ **Gestion timeout** avanc√©e

### üìä Interpr√©tation qualit√© air

- **6 niveaux** de qualit√© (Tr√®s bon ‚Üí Tr√®s mauvais)
- **Emojis et couleurs** pour interface utilisateur
- **Seuils OMS** respect√©s
- **Ratio PM2.5/PM10** avec interpr√©tation

### ‚ö° Optimisations

- **CPU efficient** : √âtats finis pour √©conomie d'√©nergie
- **M√©moire optimis√©e** : Buffer circulaire statique
- **UART haute vitesse** : 9600 bauds
- **DMA circulaire** pour mode continu

## üì¶ Installation

### Structure des fichiers

```
Drivers/STM32_MP25/
‚îú‚îÄ‚îÄ STM32_MP25.h          # D√©clarations et structures
‚îú‚îÄ‚îÄ STM32_MP25.c          # Impl√©mentation
‚îî‚îÄ‚îÄ README.md            # Documentation
```

### Configuration STM32CubeIDE

1. **Ajouter les fichiers** dans votre projet :

   ```
   Drivers/STM32_MP25/STM32_MP25.h
   Drivers/STM32_MP25/STM32_MP25.c
   ```

2. **Configurer l'UART** :

   - UART1 √† 9600 bauds
   - 8 bits, pas de parit√©, 1 stop bit
   - Mode TX/RX

3. **Configurer le GPIO** :

   - Pin SET (PA8 par d√©faut)
   - Mode Output Push-Pull

4. **Configurer le DMA** (pour mode continu) :
   - Canal DMA1_Channel5 pour UART1_RX
   - Mode circulaire
   - Interruptions activ√©es

## ‚öôÔ∏è Configuration

### Initialisation de base

```c
#include "STM32_MP25.h"

// Configuration minimale
PM25_SetDebugMode(0);                    // Debug d√©sactiv√©
PM25_SetControlPin(GPIOA, GPIO_PIN_8);   // Pin SET = PA8
PM25_Init(&huart1);                      // UART configur√©
```

### Configuration avanc√©e

```c
// Configuration compl√®te avec callbacks
PM25_SetDebugMode(1);                    // Debug activ√©
PM25_SetControlPin(GPIOA, GPIO_PIN_8);   // Pin de contr√¥le
PM25_Init(&huart1);                      // Initialisation

// Fonctions futures (r√©serv√©es pour extensions)
PM25_SetFilterThreshold(5);              // Filtrage doublons (futur)
PM25_SetUserCallback(my_callback);       // Callback personnalis√© (futur)
```

**Explication :**

- `PM25_SetDebugMode(1)` : Active les messages de debug de la librairie
- `PM25_SetControlPin()` : D√©finit la pin GPIO pour contr√¥ler le capteur
- `PM25_Init()` : Configure l'UART pour communiquer avec le capteur
- **Note** : Certaines fonctions avanc√©es sont r√©serv√©es pour de futures extensions

```

**Explication :**

- `PM25_SetFilterThreshold(5)` : Filtre les doublons de donn√©es (optionnel)
- `PM25_SetUserCallback()` : Callback personnalis√© pour traitement avanc√© (optionnel)
```

## üìö API Reference

### Structures de donn√©es

#### PM25_FullData

```c
typedef struct {
    uint8_t  raw_frame[32];           // Trame brute re√ßue
    uint16_t pm1_0_standard;          // PM1.0 standard
    uint16_t pm2_5_standard;          // PM2.5 standard
    uint16_t pm10_standard;           // PM10 standard
    uint16_t pm1_0_atmospheric;       // PM1.0 atmosph√©rique
    uint16_t pm2_5_atmospheric;       // PM2.5 atmosph√©rique
    uint16_t pm10_atmospheric;        // PM10 atmosph√©rique
    uint16_t particles_0_3um;         // Particules >0.3¬µm
    uint16_t particles_0_5um;         // Particules >0.5¬µm
    uint16_t particles_1_0um;         // Particules >1.0¬µm
    uint16_t particles_2_5um;         // Particules >2.5¬µm
    uint16_t particles_5_0um;         // Particules >5.0¬µm
    uint16_t particles_10um;          // Particules >10¬µm
    uint8_t  version;                 // Version firmware
    uint16_t checksum;                // Checksum calcul√©
} PM25_FullData;
```

#### PM_StatusInfo

```c
typedef struct {
    int         index;                // Code num√©rique
    const char* emoji;                // Emoji repr√©sentatif
    const char* label;                // Label textuel
    const char* description;          // Description d√©taill√©e
} PM_StatusInfo;
```

### Fonctions principales

#### Configuration

```c
void PM25_SetDebugMode(int enable);
void PM25_SetControlPin(GPIO_TypeDef *port, uint16_t pin);
void PM25_Init(UART_HandleTypeDef *huart);
```

#### Lecture de donn√©es

```c
// Mode polling continu ou p√©riodique
int PM25_Polling_ReadFull(UART_HandleTypeDef *huart,
                         PM25_FullData *data,
                         uint32_t interval_ms);

// Mode DMA IT continu ou p√©riodique
int PM25_DMA_ReadFull_IT(UART_HandleTypeDef *huart,
                        PM25_FullData *data,
                        uint32_t interval_ms);
```

#### Validation

```c
int PM25_Validate_Checksum(const uint8_t *frame);
```

#### Interpr√©tation qualit√© air

```c
int PM25_Quality_GetCode(uint16_t pm, const char *type);
PM_StatusInfo PM25_Quality_InterpretCode(int code);

int PM25_Ratio_GetCode(uint16_t pm25, uint16_t pm10);
PM_StatusInfo PM25_Ratio_Interpret(int code);
```

### Codes de retour

| Valeur | Signification                   |
| ------ | ------------------------------- |
| `1`    | Succ√®s - Donn√©es valides re√ßues |
| `0`    | √âchec - Timeout ou erreur       |
| `-1`   | En cours - Attente de donn√©es   |

## üí° Programme d'exemples

### Mode Polling

Le mode polling utilise une approche synchrone avec gestion d'√©tat optimis√©e pour √©conomiser l'√©nergie du microcontr√¥leur.

#### 1. Includes

```c
/* USER CODE BEGIN Includes */
#include <stdio.h>
#include "STM32_MP25.h"
/* USER CODE END Includes */
```

**Explication :**

- `stdio.h` : Pour utiliser `printf()` et afficher des messages de debug
- `STM32_MP25.h` : Interface de la librairie PM2.5 (structures, fonctions, constantes)

#### 2. Fonction utilisateur

```c
/* USER CODE BEGIN 0 */
int __io_putchar(int ch)
{
  HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
  return ch;
}

void display_pm25_data(PM25_FullData *donnees)
{
  // Affichage trame brute directement depuis la structure
  printf("\n=== Trame re√ßue (32 octets) ===\n");
  for (int i = 0; i < PM25_FRAME_LEN; i++) // PM25_FRAME_LEN = 32
  {
    printf("%02X ", donnees->raw_frame[i]); // Affichage de chaque octet en hexad√©cimal
  }
  printf("\n");

  // V√©rification du checksum
  if (PM25_Validate_Checksum(donnees->raw_frame))
  {
    printf("‚úÖ Checksum valide (0x%04X)\n", donnees->checksum);
  }
  else
  {
    printf("‚ùå Checksum invalide (0x%04X)\n", donnees->checksum);
  }

  // Donn√©es brutes sans interpr√©tation
  printf("\n=== Donn√©es brutes ===\n");
  printf("PM1.0 std:%d atm:%d | PM2.5 std:%d atm:%d | PM10 std:%d atm:%d\n",
         donnees->pm1_0_standard, donnees->pm1_0_atmospheric,
         donnees->pm2_5_standard, donnees->pm2_5_atmospheric,
         donnees->pm10_standard, donnees->pm10_atmospheric);
  printf("Particules: 0.3¬µm:%d 0.5¬µm:%d 1.0¬µm:%d 2.5¬µm:%d 5.0¬µm:%d 10¬µm:%d\n",
         donnees->particles_0_3um, donnees->particles_0_5um, donnees->particles_1_0um,
         donnees->particles_2_5um, donnees->particles_5_0um, donnees->particles_10um);
  printf("Version:%d Checksum:0x%04X\n", donnees->version, donnees->checksum);

  // Interpr√©tation qualit√© PM1.0, PM2.5, PM10 (standard) et ratio
  printf("\n=== Interpr√©tation qualit√© air ===\n");
  // R√©cup√©ration des codes d'interpr√©tation
  int code_pm1 = PM25_Quality_GetCode(donnees->pm1_0_standard, "PM1.0");
  int code_pm25 = PM25_Quality_GetCode(donnees->pm2_5_standard, "PM2.5");
  int code_pm10 = PM25_Quality_GetCode(donnees->pm10_standard, "PM10");
  int code_ratio = PM25_Ratio_GetCode(donnees->pm2_5_standard, donnees->pm10_standard);

  // Interpr√©tation des codes
  PM_StatusInfo info_pm1 = PM25_Quality_InterpretCode(code_pm1);
  PM_StatusInfo info_pm25 = PM25_Quality_InterpretCode(code_pm25);
  PM_StatusInfo info_pm10 = PM25_Quality_InterpretCode(code_pm10);
  PM_StatusInfo info_ratio = PM25_Ratio_Interpret(code_ratio);

  // Affichage qualit√© air et ratio PM
  printf("Qualit√© PM1.0 : %d ¬µg/m¬≥ -> %s %s (%s)\n", donnees->pm1_0_standard, info_pm1.emoji, info_pm1.label, info_pm1.description);
  printf("Qualit√© PM2.5 : %d ¬µg/m¬≥ -> %s %s (%s)\n", donnees->pm2_5_standard, info_pm25.emoji, info_pm25.label, info_pm25.description);
  printf("Qualit√© PM10  : %d ¬µg/m¬≥ -> %s %s (%s)\n", donnees->pm10_standard, info_pm10.emoji, info_pm10.label, info_pm10.description);

  float ratio = donnees->pm10_standard > 0 ? (float)donnees->pm2_5_standard / donnees->pm10_standard : 0.0f;
  printf("\nRatio PM2.5/PM10 : %.2f -> %s %s (%s)\n", ratio, info_ratio.emoji, info_ratio.label, info_ratio.description);
}
/* USER CODE END 0 */
```

**Explication :**

- `__io_putchar()` : Redirige `printf()` vers UART2 pour le debug
- `display_pm25_data()` : Affiche les donn√©es du capteur (brutes + interpr√©t√©es)

#### 2. Initialisation

```c
/* USER CODE BEGIN 2 */
HAL_Delay(1000);
printf("====================================================\n");
printf("========= DEMO SEN0177 PM2.5 mode polling ==========\n");
printf("====================================================\n\n");
PM25_SetDebugMode(1); // Activation du mode debug
// Initialisation du capteur avec la librairie
printf("Initialisation du capteur...\n");
PM25_Init(&huart1);                    // Initialisation du capteur
PM25_SetControlPin(GPIOA, GPIO_PIN_8); // Configuration de la pin SET
printf("‚úÖ Capteur initialis√©\n");
printf("====================================================\n");
/* USER CODE END 2 */
```

**Explication :**

- `HAL_Delay(1000)` : Pause de 1 seconde pour stabiliser le syst√®me
- `PM25_SetDebugMode(1)` : Active les messages de debug de la librairie
- `PM25_Init(&huart1)` : Configure l'UART pour communiquer avec le capteur
- `PM25_SetControlPin()` : D√©finit la pin GPIO pour contr√¥ler le capteur

#### 3. Boucle principale

```c
/* USER CODE BEGIN WHILE */
  while (1)
  {
    PM25_FullData donnees; // Structure de donn√©es compl√®te

    printf("\n====================================================\n\n");
    printf("‚è≥ Attente de donn√©es...\n");

    // Lecture avec la librairie
    uint32_t polling_delay = 5000;
    if (PM25_Polling_ReadFull(&huart1, &donnees, &polling_delay)) // Lecture en continu
    {
      printf("‚úÖ Donn√©es re√ßues\n");
      display_pm25_data(&donnees);
    }
    else
    {
      printf("‚ùå Erreur lecture\n\n");
    }
    /* USER CODE END WHILE */
```

**Explication :**

- Boucle infinie qui lit les donn√©es toutes les 5 secondes
- `PM25_Polling_ReadFull()` : Fonction principale de lecture du capteur
- Gestion des erreurs avec messages de succ√®s/√©chec

#### üèóÔ∏è Architecture mode polling

##### Machine √† √©tats et broche SET

La librairie utilise une **machine √† √©tats finis** optimis√©e avec contr√¥le de la **broche SET** pour √©conomiser l'√©nergie du capteur.

**‚ö†Ô∏è Important :** La machine √† √©tats est **identique** en mode p√©riodique et continu. Seule la **dur√©e de l'√©tat 0 (veille)** change :

- **Mode p√©riodique** : √âtat 0 dure `interval_ms` (ex: 5000ms = 5 secondes)
- **Mode continu** : √âtat 0 dure quelques millisecondes seulement

##### Diagramme des √©tats (valable pour les deux modes)

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    MACHINE √Ä √âTATS FINIS                     ‚ïë
‚ïë                    Capteur PM2.5 SEN0177                     ‚ïë
‚ïë         (Identique en mode p√©riodique et continu)           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   √âTAT 0        ‚îÇ
                    ‚îÇ   VEILLE        ‚îÇ
                    ‚îÇ                 ‚îÇ
                    ‚îÇ ‚Ä¢ SET = LOW     ‚îÇ
                    ‚îÇ ‚Ä¢ Capteur OFF   ‚îÇ
                    ‚îÇ ‚Ä¢ √âconomie      ‚îÇ
                    ‚îÇ   d'√©nergie     ‚îÇ
                    ‚îÇ ‚Ä¢ Dur√©e =       ‚îÇ
                    ‚îÇ   interval_ms   ‚îÇ
                    ‚îÇ   (ou ~ms)      ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚îÇ interval_ms √©coul√©
                            ‚îÇ OU premi√®re lecture
                            ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   √âTAT 1        ‚îÇ
                    ‚îÇ  ACTIVATION     ‚îÇ
                    ‚îÇ                 ‚îÇ
                    ‚îÇ ‚Ä¢ SET = HIGH    ‚îÇ
                    ‚îÇ ‚Ä¢ Activation    ‚îÇ
                    ‚îÇ   capteur (1s)  ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚îÇ Apr√®s 1 seconde
                            ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   √âTAT 2        ‚îÇ
                    ‚îÇ   LECTURE       ‚îÇ
                    ‚îÇ                 ‚îÇ
                    ‚îÇ ‚Ä¢ SET = HIGH    ‚îÇ
                    ‚îÇ ‚Ä¢ Lecture UART  ‚îÇ
                    ‚îÇ ‚Ä¢ Buffer        ‚îÇ
                    ‚îÇ   circulaire    ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ               ‚îÇ
            Succ√®s ‚îÇ               ‚îÇ Timeout (3s)
            ‚ñº      ‚îÇ               ‚îÇ ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Donn√©es     ‚îÇ ‚îÇ   ‚îÇ   √âTAT 0    ‚îÇ
    ‚îÇ re√ßues      ‚îÇ ‚îÇ   ‚îÇ   VEILLE    ‚îÇ
    ‚îÇ SET = LOW   ‚îÇ ‚îÇ   ‚îÇ SET = LOW   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

##### √âtats d√©taill√©s

| √âtat               | Description                           | Broche SET    | Consommation | Dur√©e        |
| ------------------ | ------------------------------------- | ------------- | ------------ | ------------ |
| **0 - Veille**     | Capteur inactif, √©conomie d'√©nergie   | `LOW` (0V)    | ~1mA         | **Variable** |
| **1 - Activation** | Capteur en cours d'activation         | `HIGH` (3.3V) | ~50mA        | 1 seconde    |
| **2 - Lecture**    | Capteur actif, acquisition de donn√©es | `HIGH` (3.3V) | ~100mA       | < 3 secondes |

##### Diff√©rences entre modes

| Aspect           | Mode P√©riodique            | Mode Continu              |
| ---------------- | -------------------------- | ------------------------- |
| **Dur√©e √âtat 0** | `interval_ms` (ex: 5000ms) | ~10-50ms                  |
| **Consommation** | Tr√®s √©conomique            | Plus √©lev√©e               |
| **Usage**        | Surveillance lente         | Contr√¥le temps r√©el       |
| **Fr√©quence**    | Toutes les 5-30s           | **Toutes les ~1 seconde** |

##### Fr√©quence d'√©mission en mode continu

**‚ö†Ô∏è Important :** Selon la documentation officielle DFRobot du capteur SEN0177 :

- **SET = HIGH** : Mode continu - Le capteur envoie automatiquement les donn√©es **toutes les secondes** apr√®s chaque √©chantillonnage
- **Temps de r√©ponse** : ‚â§ 1 seconde pour l'√©chantillonnage complet
- **Fr√©quence d'√©mission** : ~1 Hz (une trame de 32 bytes toutes les ~1000ms)

##### Broche SET - Contr√¥le √©nerg√©tique

```
Broche SET (GPIO Output Push-Pull)
‚îú‚îÄ‚îÄ HIGH (3.3V) ‚Üí Capteur ACTIF
‚îÇ   ‚îú‚îÄ‚îÄ √âtat 1: Activation (1s)
‚îÇ   ‚îú‚îÄ‚îÄ √âtat 2: Lecture (max 3s)
‚îÇ   ‚îî‚îÄ‚îÄ √âmission continue: Toutes les ~1s
‚îî‚îÄ‚îÄ LOW (0V) ‚Üí Capteur VEILLE
    ‚îî‚îÄ‚îÄ √âtat 0: √âconomie d'√©nergie
        ‚îú‚îÄ‚îÄ Mode p√©riodique: Longue veille
        ‚îî‚îÄ‚îÄ Mode continu: Courte veille
```

##### Transitions et conditions

```mermaid
stateDiagram-v2
    [*] --> Veille
    Veille --> Activation: interval_ms √©coul√©
    Activation --> Lecture: Apr√®s 1s
    Lecture --> Veille: Succ√®s + SET=LOW
    Lecture --> Veille: Timeout 3s + SET=LOW
    Veille --> [*]: Fin programme
```

##### Avantages de cette architecture

- ‚úÖ **√âconomie d'√©nergie** : Capteur inactif la plupart du temps
- ‚úÖ **Fiabilit√©** : Gestion robuste des timeouts
- ‚úÖ **Performance** : Buffer circulaire optimis√©
- ‚úÖ **Maintenance** : Code modulaire et √©volutif
- ‚úÖ **Flexibilit√©** : M√™me architecture pour tous les modes

### Mode DMA

Le mode DMA utilise les interruptions UART et le DMA pour une lecture haute performance avec gestion d'√©tat optimis√©e.

#### 1. Includes

```c
/* USER CODE BEGIN Includes */
#include <stdio.h>
#include "STM32_MP25.h"
/* USER CODE END Includes */
```

**Explication :**

- `stdio.h` : Pour utiliser `printf()` et afficher des messages de debug
- `STM32_MP25.h` : Interface de la librairie PM2.5 (structures, fonctions, constantes)

#### 2. Fonction utilisateur

```c
/* USER CODE BEGIN 0 */
int __io_putchar(int ch)
{
  HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
  return ch;
}

void display_pm25_data(PM25_FullData *donnees)
{
  // Affichage trame brute directement depuis la structure
  printf("\n=== Trame re√ßue (32 octets) ===\n");
  for (int i = 0; i < PM25_FRAME_LEN; i++) // PM25_FRAME_LEN = 32
  {
    printf("%02X ", donnees->raw_frame[i]); // Affichage de chaque octet en hexad√©cimal
  }
  printf("\n");

  // V√©rification du checksum
  if (PM25_Validate_Checksum(donnees->raw_frame))
  {
    printf("‚úÖ Checksum valide (0x%04X)\n", donnees->checksum);
  }
  else
  {
    printf("‚ùå Checksum invalide (0x%04X)\n", donnees->checksum);
  }

  // Donn√©es brutes sans interpr√©tation
  printf("\n=== Donn√©es brutes ===\n");
  printf("PM1.0 std:%d atm:%d | PM2.5 std:%d atm:%d | PM10 std:%d atm:%d\n",
         donnees->pm1_0_standard, donnees->pm1_0_atmospheric,
         donnees->pm2_5_standard, donnees->pm2_5_atmospheric,
         donnees->pm10_standard, donnees->pm10_atmospheric);
  printf("Particules: 0.3¬µm:%d 0.5¬µm:%d 1.0¬µm:%d 2.5¬µm:%d 5.0¬µm:%d 10¬µm:%d\n",
         donnees->particles_0_3um, donnees->particles_0_5um, donnees->particles_1_0um,
         donnees->particles_2_5um, donnees->particles_5_0um, donnees->particles_10um);
  printf("Version:%d Checksum:0x%04X\n", donnees->version, donnees->checksum);

  // Interpr√©tation qualit√© PM1.0, PM2.5, PM10 (standard) et ratio
  printf("\n=== Interpr√©tation qualit√© air ===\n");
  // R√©cup√©ration des codes d'interpr√©tation
  int code_pm1 = PM25_Quality_GetCode(donnees->pm1_0_standard, "PM1.0");
  int code_pm25 = PM25_Quality_GetCode(donnees->pm2_5_standard, "PM2.5");
  int code_pm10 = PM25_Quality_GetCode(donnees->pm10_standard, "PM10");
  int code_ratio = PM25_Ratio_GetCode(donnees->pm2_5_standard, donnees->pm10_standard);

  // Interpr√©tation des codes
  PM_StatusInfo info_pm1 = PM25_Quality_InterpretCode(code_pm1);
  PM_StatusInfo info_pm25 = PM25_Quality_InterpretCode(code_pm25);
  PM_StatusInfo info_pm10 = PM25_Quality_InterpretCode(code_pm10);
  PM_StatusInfo info_ratio = PM25_Ratio_Interpret(code_ratio);

  // Affichage qualit√© air et ratio PM
  printf("Qualit√© PM1.0 : %d ¬µg/m¬≥ -> %s %s (%s)\n", donnees->pm1_0_standard, info_pm1.emoji, info_pm1.label, info_pm1.description);
  printf("Qualit√© PM2.5 : %d ¬µg/m¬≥ -> %s %s (%s)\n", donnees->pm2_5_standard, info_pm25.emoji, info_pm25.label, info_pm25.description);
  printf("Qualit√© PM10  : %d ¬µg/m¬≥ -> %s %s (%s)\n", donnees->pm10_standard, info_pm10.emoji, info_pm10.label, info_pm10.description);

  float ratio = donnees->pm10_standard > 0 ? (float)donnees->pm2_5_standard / donnees->pm10_standard : 0.0f;
  printf("\nRatio PM2.5/PM10 : %.2f -> %s %s (%s)\n", ratio, info_ratio.emoji, info_ratio.label, info_ratio.description);
}
/* USER CODE END 0 */
```

**Explication :**

- `__io_putchar()` : Redirige `printf()` vers UART2 pour le debug
- `display_pm25_data()` : Affiche les donn√©es du capteur (brutes + interpr√©t√©es)

#### 3. Initialisation

```c
/* USER CODE BEGIN 2 */
HAL_Delay(1000);
printf("====================================================\n");
printf("========= DEMO SEN0177 PM2.5 mode DMA ==============\n");
printf("====================================================\n\n");
PM25_SetDebugMode(1); // Activation du mode debug
// Initialisation du capteur avec la librairie
printf("Initialisation du capteur...\n");
PM25_Init(&huart1);                    // Initialisation du capteur
PM25_SetControlPin(GPIOA, GPIO_PIN_8); // Configuration de la pin SET
printf("‚úÖ Capteur initialis√©\n");
printf("====================================================\n");
extern volatile uint8_t usart1_idle_flag; // D√©claration externe du flag
/* USER CODE END 2 */
```

**Explication :**

- `HAL_Delay(1000)` : Pause de 1 seconde pour stabiliser le syst√®me
- `PM25_SetDebugMode(1)` : Active les messages de debug de la librairie
- `PM25_Init(&huart1)` : Configure l'UART pour communiquer avec le capteur
- `PM25_SetControlPin()` : D√©finit la pin GPIO pour contr√¥ler le capteur
- `usart1_idle_flag` : Flag partag√© avec la librairie pour la synchronisation DMA

#### 4. Boucle principale

```c
/* USER CODE BEGIN WHILE */
  while (1)
  {
    PM25_FullData donnees; // Structure de donn√©es compl√®te

    printf("\n====================================================\n\n");
    printf("‚è≥ Attente de donn√©es...\n");

    // Lecture avec la librairie en mode DMA
    uint32_t dma_delay = 5000; // Intervalle de 5 secondes
    if (PM25_DMA_ReadFull_IT(&huart1, &donnees, dma_delay)) // Lecture DMA
    {
      printf("‚úÖ Donn√©es re√ßues\n");
      display_pm25_data(&donnees);
    }
    else
    {
      printf("‚ùå Erreur lecture\n\n");
    }
    /* USER CODE END WHILE */
```

**Explication :**

- Boucle infinie qui lit les donn√©es toutes les 5 secondes via DMA
- `PM25_DMA_ReadFull_IT()` : Fonction principale de lecture DMA du capteur
- Gestion des erreurs avec messages de succ√®s/√©chec

#### 5. Fichier "stm32XXxx_it.c" des interruptions

```c
/* USER CODE BEGIN Includes */
#include "STM32_MP25.h"
#include <stdio.h>
/* USER CODE END Includes */
```

```c
/* USER CODE BEGIN PV */
extern volatile uint8_t usart1_idle_flag;
extern volatile uint32_t dma1_head_snapshot;
/* USER CODE END PV */
```

```c
/* USER CODE BEGIN USART1_IRQn 0 */
  /* Minimal IRQ-safe snapshot (kept outside USER CODE to keep BEGIN block empty) */
  __HAL_UART_CLEAR_IDLEFLAG(&huart1);
  /* Capture DMA head position and notify main loop (no printf here) */
  if (huart1.hdmarx != NULL)
  {
    uint32_t cnt = __HAL_DMA_GET_COUNTER(huart1.hdmarx);
    dma1_head_snapshot = 32 - cnt; /* buffer length is 32 */
    usart1_idle_flag = 1;
  }
  /* USER CODE END USART1_IRQn 0 */
```

**Explication :**

- **Includes** : N√©cessaires pour acc√©der aux flags de la librairie
- **Variables externes** : `usart1_idle_flag` et `dma1_head_snapshot` partag√©s avec la librairie
- **Handler USART1** : Capture la position DMA et signale l'arriv√©e de donn√©es
- **IRQ-safe** : Code minimal dans l'interruption (pas de printf)

##### Diagramme des √©tats DMA (valable pour les deux modes)

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    MACHINE √Ä √âTATS FINIS                     ‚ïë
‚ïë                    Capteur PM2.5 SEN0177                     ‚ïë
‚ïë                   Mode DMA + Interruptions                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   √âTAT 0        ‚îÇ
                    ‚îÇ   VEILLE        ‚îÇ
                    ‚îÇ                 ‚îÇ
                    ‚îÇ ‚Ä¢ SET = LOW     ‚îÇ
                    ‚îÇ ‚Ä¢ Capteur OFF   ‚îÇ
                    ‚îÇ ‚Ä¢ DMA arr√™t√©    ‚îÇ
                    ‚îÇ ‚Ä¢ Dur√©e =       ‚îÇ
                    ‚îÇ   interval_ms   ‚îÇ
                    ‚îÇ   (ou ~ms)      ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚îÇ interval_ms √©coul√©
                            ‚îÇ OU premi√®re lecture
                            ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   √âTAT 1        ‚îÇ
                    ‚îÇ  ACTIVATION     ‚îÇ
                    ‚îÇ                 ‚îÇ
                    ‚îÇ ‚Ä¢ SET = HIGH    ‚îÇ
                    ‚îÇ ‚Ä¢ Activation    ‚îÇ
                    ‚îÇ   capteur (1s)  ‚îÇ
                    ‚îÇ ‚Ä¢ Pr√©paration   ‚îÇ
                    ‚îÇ   DMA           ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚îÇ Apr√®s 1 seconde
                            ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   √âTAT 2        ‚îÇ
                    ‚îÇ   LECTURE DMA   ‚îÇ
                    ‚îÇ                 ‚îÇ
                    ‚îÇ ‚Ä¢ SET = HIGH    ‚îÇ
                    ‚îÇ ‚Ä¢ DMA actif     ‚îÇ
                    ‚îÇ ‚Ä¢ Buffer        ‚îÇ
                    ‚îÇ   circulaire    ‚îÇ
                    ‚îÇ ‚Ä¢ Attente IT    ‚îÇ
                    ‚îÇ   IDLE          ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ               ‚îÇ
            IT IDLE ‚îÇ               ‚îÇ Timeout (3s/10s)
            ‚ñº      ‚îÇ               ‚îÇ ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Donn√©es     ‚îÇ ‚îÇ   ‚îÇ   √âTAT 0    ‚îÇ
    ‚îÇ re√ßues      ‚îÇ ‚îÇ   ‚îÇ   VEILLE    ‚îÇ
    ‚îÇ SET = LOW   ‚îÇ ‚îÇ   ‚îÇ SET = LOW   ‚îÇ
    ‚îÇ DMA arr√™t√©  ‚îÇ ‚îÇ   ‚îÇ DMA arr√™t√©  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

##### √âtats d√©taill√©s DMA

| √âtat                | Description                   | Broche SET    | DMA         | CPU           | Dur√©e        |
| ------------------- | ----------------------------- | ------------- | ----------- | ------------- | ------------ |
| **0 - Veille**      | Capteur inactif, DMA arr√™t√©   | `LOW` (0V)    | Arr√™t√©      | Libre         | **Variable** |
| **1 - Activation**  | Capteur en cours d'activation | `HIGH` (3.3V) | Pr√©paration | Configuration | 1 seconde    |
| **2 - Lecture DMA** | Capteur actif, DMA r√©ception  | `HIGH` (3.3V) | Actif       | Libre         | < 3s/10s     |

##### Flux de donn√©es DMA

```mermaid
graph TD
    A[Main Loop] --> B[PM25_DMA_ReadFull_IT]
    B --> C[SET = HIGH]
    C --> D[HAL_UART_Receive_DMA]
    D --> E[DMA Buffer Circulaire]
    E --> F[Capteur envoie donn√©es]
    F --> G[Interrupt IDLE d√©tect√©e]
    G --> H[USART1_IRQHandler]
    H --> I[usart1_idle_flag = 1]
    I --> J[Librairie traite trame]
    J --> K[SET = LOW]
    K --> L[DMA arr√™t√©]
    L --> A
```

##### Transitions et conditions DMA

```mermaid
stateDiagram-v2
    [*] --> Veille
    Veille --> Activation: interval_ms √©coul√©
    Activation --> Lecture_DMA: Apr√®s 1s + DMA pr√™t
    Lecture_DMA --> Veille: Succ√®s + SET=LOW + DMA stop
    Lecture_DMA --> Veille: Timeout + SET=LOW + DMA stop
    Lecture_DMA --> Lecture_DMA: Mode continu + IT IDLE
    Veille --> [*]: Fin programme
```

##### Variables globales de la librairie DMA

La librairie utilise des **variables globales volatiles** pour la synchronisation DMA :

```c
// Dans STM32_MP25.c
volatile uint8_t usart1_idle_flag = 0;     // Flag de donn√©es disponibles
volatile uint32_t dma1_head_snapshot = 0;  // Position DMA captur√©e
uint8_t async_buffer[PM25_FRAME_LEN * 2];  // Buffer circulaire DMA (64 bytes)
```

**Explication des variables :**

- **`usart1_idle_flag`** : Signal√© par l'interruption quand des donn√©es arrivent
- **`dma1_head_snapshot`** : Position du pointeur DMA lors de l'interruption
- **`async_buffer`** : Buffer circulaire de 64 bytes (2x taille trame) pour le DMA

##### Synchronisation DMA

```mermaid
sequenceDiagram
    participant Main
    participant DMA
    participant IT
    participant Librairie

    Main->>Librairie: PM25_DMA_ReadFull_IT()
    Librairie->>DMA: HAL_UART_Receive_DMA()
    DMA->>IT: Donn√©es re√ßues
    IT->>Librairie: usart1_idle_flag = 1
    Librairie->>Librairie: Traitement trame
    Librairie->>Main: Donn√©es pr√™tes
```

##### Avantages du mode DMA

- ‚úÖ **Performance √©lev√©e** : DMA g√®re la r√©ception en arri√®re-plan
- ‚úÖ **CPU lib√©r√©** : Interruptions pour traitement asynchrone
- ‚úÖ **Buffer circulaire** : Gestion automatique des donn√©es partielles
- ‚úÖ **√âconomie d'√©nergie** : M√™me gestion SET que le mode polling
- ‚úÖ **Fiabilit√©** : D√©tection automatique de fin de trame (IDLE)
- ‚úÖ **Synchronisation** : Flags volatiles pour communication thread-safe
